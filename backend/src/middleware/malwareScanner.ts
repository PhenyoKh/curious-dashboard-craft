import { Request, Response, NextFunction } from 'express';
const NodeClam = require('clamscan');
import { promises as fs } from 'fs';
import path from 'path';

interface ScanResult {
  isInfected: boolean;
  viruses: string[];
  file?: string;
}

class MalwareScanner {
  private clamscan: any | null = null;
  private initialized = false;

  async initialize(): Promise<void> {
    if (this.initialized) return;

    try {
      this.clamscan = await new NodeClam().init({
        removeInfected: true,
        quarantineInfected: false,
        scanLog: null,
        debugMode: process.env.NODE_ENV === 'development',
        clamscan: {
          path: '/usr/bin/clamscan',
          scanArchives: true,
          active: false
        },
        clamdscan: {
          socket: false,
          host: 'localhost',
          port: 3310,
          timeout: 60000,
          localFallback: true,
          active: true
        },
        preference: 'clamdscan'
      });

      this.initialized = true;
      console.log('‚úÖ Malware scanner initialized successfully');
    } catch (error) {
      console.warn('‚ö†Ô∏è ClamAV not available, using fallback security checks:', error);
      this.initialized = false;
    }
  }

  async scanFile(filePath: string): Promise<ScanResult> {
    if (!this.clamscan || !this.initialized) {
      return this.fallbackScan(filePath);
    }

    try {
      const result = await this.clamscan.scanFile(filePath);
      
      return {
        isInfected: result.isInfected || false,
        viruses: result.viruses || [],
        file: filePath
      };
    } catch (error) {
      console.error('Malware scan failed:', error);
      return this.fallbackScan(filePath);
    }
  }

  private async fallbackScan(filePath: string): Promise<ScanResult> {
    try {
      const stats = await fs.stat(filePath);
      const fileBuffer = await fs.readFile(filePath);
      
      // Basic security checks without ClamAV
      const suspiciousPatterns = [
        /\x4d\x5a/,           // PE executable header
        /\x7f\x45\x4c\x46/,   // ELF header
        /<script\b/i,         // Script tags
        /javascript:/i,       // JavaScript URLs
        /vbscript:/i,         // VBScript URLs
        /data:text\/html/i,   // HTML data URLs
        /\$\{|\#\{/,         // Template injection patterns
        /%3Cscript/i,        // URL encoded script
        /&#x/i,              // HTML entity encoding
      ];

      const content = fileBuffer.toString('utf8', 0, Math.min(1024, fileBuffer.length));
      const isSuspicious = suspiciousPatterns.some(pattern => pattern.test(content));

      // File size checks
      const maxSize = 10 * 1024 * 1024; // 10MB
      if (stats.size > maxSize) {
        return {
          isInfected: true,
          viruses: ['FILE_TOO_LARGE'],
          file: filePath
        };
      }

      return {
        isInfected: isSuspicious,
        viruses: isSuspicious ? ['SUSPICIOUS_CONTENT'] : [],
        file: filePath
      };
    } catch (error) {
      console.error('Fallback scan failed:', error);
      return {
        isInfected: true,
        viruses: ['SCAN_ERROR'],
        file: filePath
      };
    }
  }
}

const scanner = new MalwareScanner();

export const initializeMalwareScanner = async (): Promise<void> => {
  await scanner.initialize();
};

export const scanUploadedFile = () => {
  return async (req: Request, res: Response, next: NextFunction) => {
    const file = (req as any).file;
    const files = (req as any).files;

    if (!file && !files) {
      return next();
    }

    try {
      const filesToScan = files ? (Array.isArray(files) ? files : Object.values(files).flat()) : [file];

      for (const uploadedFile of filesToScan) {
        if (!uploadedFile?.path) continue;

        const scanResult = await scanner.scanFile(uploadedFile.path);

        if (scanResult.isInfected) {
          // Clean up infected file
          try {
            await fs.unlink(uploadedFile.path);
          } catch (cleanupError) {
            console.error('Failed to delete infected file:', cleanupError);
          }

          // Log security event
          console.error('üö® SECURITY ALERT - Malware detected:', {
            timestamp: new Date().toISOString(),
            filename: uploadedFile.originalname,
            path: uploadedFile.path,
            size: uploadedFile.size,
            mimetype: uploadedFile.mimetype,
            viruses: scanResult.viruses,
            ip: req.ip,
            userAgent: req.get('User-Agent'),
            userId: (req as any).user?.id
          });

          return res.status(400).json({
            success: false,
            error: 'File rejected: Security scan detected potential threats',
            data: {
              threats: scanResult.viruses,
              message: 'Upload blocked for security reasons'
            }
          });
        }
      }

      next();
    } catch (error) {
      console.error('Malware scanning error:', error);
      
      // Clean up files on error
      const filesToClean = files ? (Array.isArray(files) ? files : Object.values(files).flat()) : [file];
      for (const uploadedFile of filesToClean) {
        if (uploadedFile?.path) {
          try {
            await fs.unlink(uploadedFile.path);
          } catch (cleanupError) {
            console.error('Failed to cleanup file after scan error:', cleanupError);
          }
        }
      }

      return res.status(500).json({
        success: false,
        error: 'Security scan failed',
        data: {
          message: 'Unable to verify file safety'
        }
      });
    }
  };
};

export { scanner as malwareScanner };