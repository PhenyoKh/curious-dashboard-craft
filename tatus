[1mdiff --git a/src/hooks/useHighlightRestoration.tsx b/src/hooks/useHighlightRestoration.tsx[m
[1mindex 7da7f3a..c76519d 100644[m
[1m--- a/src/hooks/useHighlightRestoration.tsx[m
[1m+++ b/src/hooks/useHighlightRestoration.tsx[m
[36m@@ -13,9 +13,22 @@[m [mexport const useHighlightRestoration = ([m
   editor: Editor | null,[m
   setHighlights: (highlights: Highlight[]) => void,[m
   categories: HighlightCategories,[m
[31m-  resequenceCategory?: (category: keyof HighlightCategories) => void[m
[32m+[m[32m  resequenceCategory?: (category: keyof HighlightCategories) => void,[m
[32m+[m[32m  savedSidecar?: Array<{ id: string; commentary?: string; isExpanded?: boolean }>[m
 ) => {[m
   const hasRestoredRef = useRef(false);[m
[32m+[m[32m  const savedMapRef = useRef<Map<string, { commentary?: string; isExpanded?: boolean }>>(new Map());[m
[32m+[m
[32m+[m[32m  // Keep a map of saved commentary by id for efficient merging[m
[32m+[m[32m  useEffect(() => {[m
[32m+[m[32m    const map = new Map<string, { commentary?: string; isExpanded?: boolean }>();[m
[32m+[m[32m    (savedSidecar || []).forEach(entry => {[m
[32m+[m[32m      if (entry && typeof entry.id === 'string') {[m
[32m+[m[32m        map.set(entry.id, { commentary: entry.commentary || '', isExpanded: !!entry.isExpanded });[m
[32m+[m[32m      }[m
[32m+[m[32m    });[m
[32m+[m[32m    savedMapRef.current = map;[m
[32m+[m[32m  }, [savedSidecar]);[m
 [m
   useEffect(() => {[m
     logger.log('ðŸ”„ useHighlightRestoration useEffect triggered', {[m
[36m@@ -83,8 +96,8 @@[m [mexport const useHighlightRestoration = ([m
               category: category as keyof HighlightCategories,[m
               number: Number(number) || 1,[m
               text: combinedText,[m
[31m-              commentary: '',[m
[31m-              isExpanded: false,[m
[32m+[m[32m              commentary: savedMapRef.current.get(id)?.commentary || '',[m
[32m+[m[32m              isExpanded: !!savedMapRef.current.get(id)?.isExpanded,[m
             };[m
             highlightsMap.set(id, highlight);[m
             logger.log(`âž• Added DOM highlight (${elements.length} elements):`, highlight);[m
[36m@@ -200,13 +213,14 @@[m [mexport const useHighlightRestoration = ([m
             logger.log(`âœ¨ Found new format highlight ID: ${id}`);[m
           }[m
 [m
[32m+[m[32m          const saved = savedMapRef.current.get(finalId);[m
           const highlight = {[m
             id: finalId,[m
             category: data.category as keyof HighlightCategories,[m
             number: finalNumber,[m
             text: fullText,[m
[31m-            commentary: '',[m
[31m-            isExpanded: false,[m
[32m+[m[32m            commentary: saved?.commentary || '',[m
[32m+[m[32m            isExpanded: !!saved?.isExpanded,[m
           };[m
 [m
           logger.log(`âž• Creating highlight:`, {[m
[1mdiff --git a/src/hooks/useNoteState.tsx b/src/hooks/useNoteState.tsx[m
[1mindex 4201084..c98d1b0 100644[m
[1m--- a/src/hooks/useNoteState.tsx[m
[1m+++ b/src/hooks/useNoteState.tsx[m
[36m@@ -33,6 +33,8 @@[m [mexport const useNoteState = () => {[m
   const [showPlaceholder, setShowPlaceholder] = useState<boolean>(true);[m
   const [subjects, setSubjects] = useState<Database['public']['Tables']['subjects']['Row'][]>([]);[m
   const [isLoading, setIsLoading] = useState<boolean>(!!noteId);[m
[32m+[m[32m  // Sidecar highlights stored in Supabase JSONB: [{ id, commentary, isExpanded }][m
[32m+[m[32m  const [highlightsSidecar, setHighlightsSidecar] = useState<Array<{ id: string; commentary?: string; isExpanded?: boolean }>>([]);[m
   [m
   // Load existing note if noteId is provided[m
   useEffect(() => {[m
[36m@@ -52,6 +54,9 @@[m [mexport const useNoteState = () => {[m
           });[m
           setWordCount(getWordCountFromHtml(note.content || ''));[m
           setShowPlaceholder((note.content || '').trim() === '' || note.content === '<br>');[m
[32m+[m[32m          // Backward compatible load of highlights JSONB (may be null/absent on legacy rows)[m
[32m+[m[32m          const loadedHighlights = Array.isArray((note as any).highlights) ? (note as any).highlights as Array<{ id: string; commentary?: string; isExpanded?: boolean }> : [];[m
[32m+[m[32m          setHighlightsSidecar(loadedHighlights.filter(h => typeof h?.id === 'string').map(h => ({ id: h.id, commentary: h.commentary || '', isExpanded: !!h.isExpanded })));[m
         }[m
       } catch (error) {[m
         logger.error('Error loading note:', error);[m
[36m@@ -92,13 +97,20 @@[m [mexport const useNoteState = () => {[m
       [m
       // Generate plain text version for search and export[m
       const contentText = htmlToText(content);[m
[32m+[m[32m      // Ensure we only persist commentary for highlights that exist in the editor right now[m
[32m+[m[32m      // Caller should have kept highlightsSidecar in sync with editor highlights; still filter for safety[m
[32m+[m[32m      const sanitizedHighlights = (highlightsSidecar || [])[m
[32m+[m[32m        .filter(h => h && typeof h.id === 'string')[m
[32m+[m[32m        .map(h => ({ id: h.id, commentary: h.commentary || '', isExpanded: !!h.isExpanded }));[m
       [m
       const saveData = {[m
         title: title.trim() || 'Untitled Note',[m
         content: content,[m
         content_text: contentText,[m
         subject_id: metadata.subject || null,[m
[31m-        word_count: wordCount || 0[m
[32m+[m[32m        word_count: wordCount || 0,[m
[32m+[m[32m        // Persist sidecar highlights JSONB[m
[32m+[m[32m        highlights: sanitizedHighlights,[m
       };[m
       [m
       logger.log('ðŸ” performAutoSave: Saving data:', {[m
[36m@@ -106,7 +118,8 @@[m [mexport const useNoteState = () => {[m
         contentLength: saveData.content.length,[m
         contentTextLength: saveData.content_text.length,[m
         wordCount: saveData.word_count,[m
[31m-        subjectId: saveData.subject_id[m
[32m+[m[32m        subjectId: saveData.subject_id,[m
[32m+[m[32m        highlightsCount: sanitizedHighlights.length[m
       });[m
       [m
       if (noteId) {[m
[36m@@ -117,7 +130,8 @@[m [mexport const useNoteState = () => {[m
           title: updatedNote.title,[m
           contentLength: updatedNote.content?.length || 0,[m
           contentTextLength: updatedNote.content_text?.length || 0,[m
[31m-          wordCount: updatedNote.word_count[m
[32m+[m[32m          wordCount: updatedNote.word_count,[m
[32m+[m[32m          highlightsCount: Array.isArray((updatedNote as any).highlights) ? (updatedNote as any).highlights.length : 0[m
         });[m
       } else {[m
         // Create new note and get the ID for future saves[m
[36m@@ -128,7 +142,8 @@[m [mexport const useNoteState = () => {[m
             title: newNote.title,[m
             contentLength: newNote.content?.length || 0,[m
             contentTextLength: newNote.content_text?.length || 0,[m
[31m-            wordCount: newNote.word_count[m
[32m+[m[32m            wordCount: newNote.word_count,[m
[32m+[m[32m            highlightsCount: Array.isArray((newNote as any).highlights) ? (newNote as any).highlights.length : 0[m
           });[m
           // Update the URL to include the new note ID[m
           window.history.replaceState({}, '', `/note/${newNote.id}`);[m
[36m@@ -141,8 +156,96 @@[m [mexport const useNoteState = () => {[m
       logger.error('Error saving note:', error);[m
       setIsAutoSaved(true); // Reset UI state even on error[m
     }[m
[32m+[m[32m  }, [noteId, title, content, metadata.subject, wordCount, highlightsSidecar]);[m
[32m+[m
[32m+[m[32m  /**[m
[32m+[m[32m   * Helper function to perform autosave with specific highlights data.[m
[32m+[m[32m   * This avoids the stale closure issue by accepting highlights as a parameter[m
[32m+[m[32m   * instead of relying on the highlightsSidecar state.[m
[32m+[m[32m   */[m
[32m+[m[32m  const performAutoSaveWithHighlights = useCallback(async (highlights: Array<{ id: string; commentary?: string; isExpanded?: boolean }>) => {[m
[32m+[m[32m    try {[m
[32m+[m[32m      setIsAutoSaved(false);[m
[32m+[m[41m      [m
[32m+[m[32m      // Generate plain text version for search and export[m
[32m+[m[32m      const contentText = htmlToText(content);[m
[32m+[m[32m      // Use the passed highlights directly instead of state to avoid stale closure[m
[32m+[m[32m      const sanitizedHighlights = (highlights || [])[m
[32m+[m[32m        .filter(h => h && typeof h.id === 'string')[m
[32m+[m[32m        .map(h => ({ id: h.id, commentary: h.commentary || '', isExpanded: !!h.isExpanded }));[m
[32m+[m[41m      [m
[32m+[m[32m      const saveData = {[m
[32m+[m[32m        title: title.trim() || 'Untitled Note',[m
[32m+[m[32m        content: content,[m
[32m+[m[32m        content_text: contentText,[m
[32m+[m[32m        subject_id: metadata.subject || null,[m
[32m+[m[32m        word_count: wordCount || 0,[m
[32m+[m[32m        // Persist sidecar highlights JSONB[m
[32m+[m[32m        highlights: sanitizedHighlights,[m
[32m+[m[32m      };[m
[32m+[m[41m      [m
[32m+[m[32m      logger.log('ðŸ” performAutoSaveWithHighlights: Saving data:', {[m
[32m+[m[32m        title: saveData.title,[m
[32m+[m[32m        contentLength: saveData.content.length,[m
[32m+[m[32m        contentTextLength: saveData.content_text.length,[m
[32m+[m[32m        wordCount: saveData.word_count,[m
[32m+[m[32m        subjectId: saveData.subject_id,[m
[32m+[m[32m        highlightsCount: sanitizedHighlights.length[m
[32m+[m[32m      });[m
[32m+[m[41m      [m
[32m+[m[32m      if (noteId) {[m
[32m+[m[32m        // Update existing note[m
[32m+[m[32m        const updatedNote = await updateNoteById(noteId, saveData);[m
[32m+[m[32m        logger.log('âœ… Note updated successfully with highlights:', {[m
[32m+[m[32m          id: updatedNote.id,[m
[32m+[m[32m          title: updatedNote.title,[m
[32m+[m[32m          contentLength: updatedNote.content?.length || 0,[m
[32m+[m[32m          contentTextLength: updatedNote.content_text?.length || 0,[m
[32m+[m[32m          wordCount: updatedNote.word_count,[m
[32m+[m[32m          highlightsCount: Array.isArray((updatedNote as any).highlights) ? (updatedNote as any).highlights.length : 0[m
[32m+[m[32m        });[m
[32m+[m[32m      } else {[m
[32m+[m[32m        // Create new note and get the ID for future saves[m
[32m+[m[32m        const newNote = await createNote(saveData);[m
[32m+[m[32m        if (newNote && newNote.id) {[m
[32m+[m[32m          logger.log('âœ… New note created successfully with highlights:', {[m
[32m+[m[32m            id: newNote.id,[m
[32m+[m[32m            title: newNote.title,[m
[32m+[m[32m            contentLength: newNote.content?.length || 0,[m
[32m+[m[32m            contentTextLength: newNote.content_text?.length || 0,[m
[32m+[m[32m            wordCount: newNote.word_count,[m
[32m+[m[32m            highlightsCount: Array.isArray((newNote as any).highlights) ? (newNote as any).highlights.length : 0[m
[32m+[m[32m          });[m
[32m+[m[32m          // Update the URL to include the new note ID[m
[32m+[m[32m          window.history.replaceState({}, '', `/note/${newNote.id}`);[m
[32m+[m[32m        }[m
[32m+[m[32m      }[m
[32m+[m[41m      [m
[32m+[m[32m      setMetadata(prev => ({ ...prev, modifiedAt: new Date() }));[m
[32m+[m[32m      setIsAutoSaved(true);[m
[32m+[m[32m    } catch (error) {[m
[32m+[m[32m      logger.error('Error saving note with highlights:', error);[m
[32m+[m[32m      setIsAutoSaved(true); // Reset UI state even on error[m
[32m+[m[32m    }[m
   }, [noteId, title, content, metadata.subject, wordCount]);[m
 [m
[32m+[m[32m  /**[m
[32m+[m[32m   * Ingest full editor highlights, extract only sidecar fields, and trigger save pipeline.[m
[32m+[m[32m   * Also prunes orphans implicitly by replacing with the current set from editor.[m
[32m+[m[32m   */[m
[32m+[m[32m  const updateHighlightsFromEditor = useCallback((editorHighlights: Highlight[]) => {[m
[32m+[m[32m    try {[m
[32m+[m[32m      const next = (editorHighlights || []).map(h => ({ id: h.id, commentary: h.commentary || '', isExpanded: !!h.isExpanded }));[m
[32m+[m[32m      setHighlightsSidecar(next);[m
[32m+[m[41m      [m
[32m+[m[32m      // Call performAutoSave with the fresh highlights data directly[m
[32m+[m[32m      // This avoids the stale closure issue by passing the data as a parameter[m
[32m+[m[32m      performAutoSaveWithHighlights(next);[m
[32m+[m[32m    } catch (error) {[m
[32m+[m[32m      logger.error('Error updating highlights from editor:', error);[m
[32m+[m[32m    }[m
[32m+[m[32m  }, [performAutoSaveWithHighlights]);[m
[32m+[m
   const deleteNote = useCallback(async (noteIdToDelete: string) => {[m
     const success = await deleteNoteService(noteIdToDelete);[m
     if (success) {[m
[36m@@ -174,6 +277,9 @@[m [mexport const useNoteState = () => {[m
     performAutoSave,[m
     isLoading,[m
     noteId,[m
[31m-    deleteNote[m
[32m+[m[32m    deleteNote,[m
[32m+[m[32m    // Expose sidecar and updater for editor integration[m
[32m+[m[32m    highlightsSidecar,[m
[32m+[m[32m    updateHighlightsFromEditor,[m
   };[m
 };[m
